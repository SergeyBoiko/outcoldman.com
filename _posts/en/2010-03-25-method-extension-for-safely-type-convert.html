---
layout: post
title: "Method extension for safely type convert"
date: 2010-03-25 19:58:00
categories: en
tags: [.NET, C#, Parse, Convert, Extension Methods]
alias: en/blog/show/196
---
<p>Recently I read good Russian post with many interesting <a href="http://nesteruk.wordpress.com/2010/03/22/extension-method-patterns/">extensions methods</a> after then I remembered that I too have one good extension method “Safely type convert”. Idea of this method I got at last job.</p>

<p>We often write code like this:</p>

<pre><code>int intValue;
if (obj == null || !int.TryParse(obj.ToString(), out intValue))
    intValue = 0;
</code></pre>

<p></p>

<p>This is method how to safely parse object to int. Of course will be good if we will create some unify method for safely casting.</p>

<p>I found that better way is to create extension methods and use them then follows:</p>

<pre><code>int i;
i = &quot;1&quot;.To&lt;int&gt;();
// i == 1
i = &quot;1a&quot;.To&lt;int&gt;();
// i == 0 (default value of int)
i = &quot;1a&quot;.To(10);
// i == 10 (set as default value 10)
i = &quot;1&quot;.To(10);
// i == 1
// ********** Nullable sample **************
int? j;
j = &quot;1&quot;.To&lt;int?&gt;();
// j == 1
j = &quot;1a&quot;.To&lt;int?&gt;();
// j == null
j = &quot;1a&quot;.To&lt;int?&gt;(10);
// j == 10
j = &quot;1&quot;.To&lt;int?&gt;(10);
// j == 1
</code></pre>

<p>Realization of this approach:</p>

<pre><code>public static class Parser
{    /// &lt;summary&gt;
    /// Try cast &lt;paramref name=&quot;obj&quot;/&gt; value to type &lt;typeparamref name=&quot;T&quot;/&gt;,
    /// if can't will return default(&lt;typeparamref name=&quot;T&quot;/&gt;)
    /// &lt;/summary&gt;
    /// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt;
    /// &lt;param name=&quot;obj&quot;&gt;&lt;/param&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    public static T To&lt;T&gt;(this object obj)
    {        return To(obj, default(T));
    }
&#160;    /// &lt;summary&gt;
    /// Try cast &lt;paramref name=&quot;obj&quot;/&gt; value to type &lt;typeparamref name=&quot;T&quot;/&gt;,
    /// if can't will return &lt;paramref name=&quot;defaultValue&quot;/&gt;
    /// &lt;/summary&gt;
    /// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt;
    /// &lt;param name=&quot;obj&quot;&gt;&lt;/param&gt;
    /// &lt;param name=&quot;defaultValue&quot;&gt;&lt;/param&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    public static T To&lt;T&gt;(this object obj, T defaultValue)
    {        if (obj == null)
            return defaultValue;
&#160;        if (obj is T)
            return (T) obj;
&#160;        Type type = typeof (T);
&#160;        // Place convert to reference types here
&#160;        if (type == typeof(string))
        {            return (T)(object)obj.ToString();
        }
&#160;
        Type underlyingType = Nullable.GetUnderlyingType(type);        if (underlyingType != null)
        {            return To(obj, defaultValue, underlyingType);
        }
&#160;        return To(obj, defaultValue, type);
    }
&#160;    private static T To&lt;T&gt;(object obj, T defaultValue, Type type)
    {        // Place convert to sructures types here
&#160;        if (type == typeof(int))
        {            int intValue;
            if (int.TryParse(obj.ToString(), out intValue))
                return (T)(object)intValue;
            return defaultValue;
        }
&#160;        if (type == typeof(long))
        {            long intValue;
            if (long.TryParse(obj.ToString(), out intValue))
                return (T)(object)intValue;
            return defaultValue;
        }
&#160;        if (type == typeof(bool))
        {            bool bValue;
            if (bool.TryParse(obj.ToString(), out bValue))
                return (T)(object)bValue;
            return defaultValue;
        }
&#160;        if (type.IsEnum)
        {            if (Enum.IsDefined(type, obj))
                return (T)Enum.Parse(type, obj.ToString());
            return defaultValue;
        }
&#160;        throw new NotSupportedException(string.Format(&quot;Couldn't parse to Type {0}&quot;, typeof(T)));
    }
}
</code></pre>


<p>This realization isn’t full – this is small method part, I use it at my site engine. It can work with int, long, bool, string, enums (with Nullable type of this types too). I think that you can add types very easy for this method (don’t forget about culture). </p>

<p>Obviously this approach you can use just inside of developers group, because It is not obviously why this method can’t cast any type A to type B.</p>

<p>

</p>
