---
layout: post
title: "RESTful WCF Service – How to get browser version at server code"
date: 2010-08-14 14:55:00
categories: en
tags: [Silverlight, .NET, C#, Internet Explorer 8, PDF, Reports, WCF, RESTful, FireFox]
alias: en/blog/show/215
---
<p>At our product we have a client Silverlight part and server-code part, which contains a lot of WCF methods. We don’t use ASP.NET Compatible mode, because we want to leave an opportunity to deploy server part to server without web-server role (without IIS). Really, I don’t know why we chose this way, because all of our installations at current moment are on IIS. But we have what we have, so we haven’t ASP.NET Compatible mode, and as an expected result we can’t get <i>HttpContext.Current</i> instance at server WCF methods. One of WCF Service is a <a href="http://msdn.microsoft.com/en-us/magazine/dd315413.aspx">RESTful service</a>, which at his methods returns report files, so it can handle GET-queries from browsers. This is standard code:</p>

<div style="border-bottom: silver 1px solid; text-align: left; border-left: silver 1px solid; padding-bottom: 4px; line-height: 12pt; background-color: #f4f4f4; margin: 20px 0px 10px; padding-left: 4px; width: 97.5%; padding-right: 4px; font-family: &#39;Courier New&#39;, courier, monospace; direction: ltr; color: black; overflow: auto; border-top: silver 1px solid; cursor: text; border-right: silver 1px solid; padding-top: 4px" id="codeSnippetWrapper">
  <div style="padding-bottom: 0px; padding-left: 0px; padding-right: 0px; padding-top: 0px" id="codeSnippet">
    <pre style="background-color: white; margin: 0em">WebOperationContext context = WebOperationContext.Current;</pre>
<!--CRLF-->

    <pre style="margin: 0em">context.OutgoingResponse.ContentLength = reportBytes.Length;</pre>
<!--CRLF-->

    <pre style="background-color: white; margin: 0em">context.OutgoingResponse.ContentType = <span style="color: #006080">&quot;application/pdf&quot;</span>;</pre>
<!--CRLF-->

    <pre style="margin: 0em">context.OutgoingResponse.Headers.Set(<span style="color: #006080">&quot;content-disposition&quot;</span>, <span style="color: #006080">&quot;attachment;filename=&quot;</span> + fileName);</pre>
<!--CRLF--></div>
</div>

<p>But we got a problem. Some files contain spaces at their names, and different browsers handle these names by their ways. First problem was: if variable filename contains name like “file with spaces.pdf”, then FireFox will show us only “file”, we solved this problem easy, need to surround file name with quotes (Really, I don’t know how many times I have been writing this code and always get the same problems):</p>

<div style="border-bottom: silver 1px solid; text-align: left; border-left: silver 1px solid; padding-bottom: 4px; line-height: 12pt; background-color: #f4f4f4; margin: 20px 0px 10px; padding-left: 4px; width: 97.5%; padding-right: 4px; font-family: &#39;Courier New&#39;, courier, monospace; direction: ltr; color: black; overflow: auto; border-top: silver 1px solid; cursor: text; border-right: silver 1px solid; padding-top: 4px" id="codeSnippetWrapper">
  <div style="padding-bottom: 0px; padding-left: 0px; padding-right: 0px; padding-top: 0px" id="codeSnippet">
    <pre style="background-color: white; margin: 0em">context.OutgoingResponse.Headers.Set(<span style="color: #006080">&quot;content-disposition&quot;</span>, <span style="color: #006080">&quot;attachment;filename=\&quot;&quot;</span> + fileName + <span style="color: #006080">&quot;\&quot;&quot;</span>);</pre>
<!--CRLF--></div>
</div>

<p>Internet Explorer has his own way to handle filenames with spaces. It replaces spaces with symbol ‘_’. I was trying to solve this problem with this code:</p>

<div style="border-bottom: silver 1px solid; text-align: left; border-left: silver 1px solid; padding-bottom: 4px; line-height: 12pt; background-color: #f4f4f4; margin: 20px 0px 10px; padding-left: 4px; width: 97.5%; padding-right: 4px; font-family: &#39;Courier New&#39;, courier, monospace; direction: ltr; color: black; overflow: auto; border-top: silver 1px solid; cursor: text; border-right: silver 1px solid; padding-top: 4px" id="codeSnippetWrapper">
  <div style="padding-bottom: 0px; padding-left: 0px; padding-right: 0px; padding-top: 0px" id="codeSnippet">
    <pre style="background-color: white; margin: 0em">filename = HttpUtility.UrlPathEncode(filename);</pre>
<!--CRLF--></div>
</div>

<p>After this line variable <i>filename</i> will has value “filename%20with%20spaces.pdf” and Internet Explorer now saves file with correct name, but FireFox leave %20 instead of spaces. So I need a way to get information at server code which browser asked file. I wrote method <i>IsInternetExplorer</i>:</p>

<div style="border-bottom: silver 1px solid; text-align: left; border-left: silver 1px solid; padding-bottom: 4px; line-height: 12pt; background-color: #f4f4f4; margin: 20px 0px 10px; padding-left: 4px; width: 97.5%; padding-right: 4px; font-family: &#39;Courier New&#39;, courier, monospace; direction: ltr; color: black; overflow: auto; border-top: silver 1px solid; cursor: text; border-right: silver 1px solid; padding-top: 4px" id="codeSnippetWrapper">
  <div style="padding-bottom: 0px; padding-left: 0px; padding-right: 0px; padding-top: 0px" id="codeSnippet">
    <pre style="background-color: white; margin: 0em"><span style="color: #0000ff">private</span> <span style="color: #0000ff">bool</span> IsInternetExplorer()</pre>
<!--CRLF-->

    <pre style="margin: 0em">{</pre>
<!--CRLF-->

    <pre style="background-color: white; margin: 0em">  WebOperationContext context = WebOperationContext.Current;</pre>
<!--CRLF-->

    <pre style="margin: 0em">  <span style="color: #0000ff">if</span> (context != <span style="color: #0000ff">null</span>)</pre>
<!--CRLF-->

    <pre style="background-color: white; margin: 0em">  {</pre>
<!--CRLF-->

    <pre style="margin: 0em">    <span style="color: #0000ff">string</span> userAgentInfo = context.IncomingRequest.Headers[<span style="color: #006080">&quot;User-Agent&quot;</span>];</pre>
<!--CRLF-->

    <pre style="background-color: white; margin: 0em">    <span style="color: #0000ff">if</span> (userAgentInfo != <span style="color: #0000ff">null</span>)</pre>
<!--CRLF-->

    <pre style="margin: 0em">      <span style="color: #0000ff">return</span> userAgentInfo.Contains(<span style="color: #006080">&quot;MSIE&quot;</span>);</pre>
<!--CRLF-->

    <pre style="background-color: white; margin: 0em">  }</pre>
<!--CRLF-->

    <pre style="margin: 0em">  <span style="color: #0000ff">return</span> <span style="color: #0000ff">false</span>;</pre>
<!--CRLF-->

    <pre style="background-color: white; margin: 0em">}</pre>
<!--CRLF--></div>
</div>

<p>So I place plug for Internet Explorer in server code:</p>

<div style="border-bottom: silver 1px solid; text-align: left; border-left: silver 1px solid; padding-bottom: 4px; line-height: 12pt; background-color: #f4f4f4; margin: 20px 0px 10px; padding-left: 4px; width: 97.5%; padding-right: 4px; font-family: &#39;Courier New&#39;, courier, monospace; direction: ltr; color: black; overflow: auto; border-top: silver 1px solid; cursor: text; border-right: silver 1px solid; padding-top: 4px" id="codeSnippetWrapper">
  <div style="padding-bottom: 0px; padding-left: 0px; padding-right: 0px; padding-top: 0px" id="codeSnippet">
    <pre style="background-color: white; margin: 0em"><span style="color: #0000ff">if</span> (IsInternetExplorer())</pre>
<!--CRLF-->

    <pre style="margin: 0em">  filename = HttpUtility.UrlPathEncode(filename);</pre>
<!--CRLF--></div>
</div>


<p>It was a surprise for me, that I couldn’t find a way to get browser version in internet. But I knew that should be the way to get user-agent string from request. At first I wrote realization with OperationContext:</p>

<div style="border-bottom: silver 1px solid; text-align: left; border-left: silver 1px solid; padding-bottom: 4px; line-height: 12pt; background-color: #f4f4f4; margin: 20px 0px 10px; padding-left: 4px; width: 97.5%; padding-right: 4px; font-family: &#39;Courier New&#39;, courier, monospace; direction: ltr; color: black; overflow: auto; border-top: silver 1px solid; cursor: text; border-right: silver 1px solid; padding-top: 4px" id="codeSnippetWrapper">
  <div style="padding-bottom: 0px; padding-left: 0px; padding-right: 0px; padding-top: 0px" id="codeSnippet">
    <pre style="background-color: white; margin: 0em"><span style="color: #0000ff">private</span> <span style="color: #0000ff">bool</span> IsInternetExplorer()</pre>
<!--CRLF-->

    <pre style="margin: 0em">{</pre>
<!--CRLF-->

    <pre style="background-color: white; margin: 0em">  OperationContext context = OperationContext.Current;</pre>
<!--CRLF-->

    <pre style="margin: 0em">  HttpRequestMessageProperty httpRequest = context.IncomingMessageProperties[<span style="color: #006080">&quot;httpRequest&quot;</span>] <span style="color: #0000ff">as</span> HttpRequestMessageProperty;</pre>
<!--CRLF-->

    <pre style="background-color: white; margin: 0em">  <span style="color: #0000ff">if</span> (httpRequest != <span style="color: #0000ff">null</span>)</pre>
<!--CRLF-->

    <pre style="margin: 0em">  {</pre>
<!--CRLF-->

    <pre style="background-color: white; margin: 0em">    <span style="color: #0000ff">string</span> userAgentInfo = httpRequest.Headers[<span style="color: #006080">&quot;User-Agent&quot;</span>];</pre>
<!--CRLF-->

    <pre style="margin: 0em">    <span style="color: #0000ff">if</span> (userAgentInfo != <span style="color: #0000ff">null</span>)</pre>
<!--CRLF-->

    <pre style="background-color: white; margin: 0em">      <span style="color: #0000ff">return</span> userAgentInfo.Contains(<span style="color: #006080">&quot;MSIE&quot;</span>);</pre>
<!--CRLF-->

    <pre style="margin: 0em">  }</pre>
<!--CRLF-->

    <pre style="background-color: white; margin: 0em">  <span style="color: #0000ff">return</span> <span style="color: #0000ff">false</span>;</pre>
<!--CRLF-->

    <pre style="margin: 0em">}</pre>
<!--CRLF--></div>
</div>

<p>But then I remembered about WebOperationContext. I think that WCF is not transparent. I will try in future to learn more about WCF and maybe will try to pass MS exam about WCF. </p>
