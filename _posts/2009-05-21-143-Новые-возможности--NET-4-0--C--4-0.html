---
layout: post
title: "Новые возможности .NET 4.0: C# 4.0"
date: 2009-05-21 23:47:00
categories: ru
tags: [.NET, C#, .NET 4.0, C# 4, Dynamic]
permalink: ru/blog/show/143
---
<p>После выхода Visual Studio 2010 beta 1 - первым делом нужно разобраться, что же дает нового нам C# 4.0 (так как это мой основной язык программирования - для меня это является важным). Первым делом должен вам порекомендовать примеры C# 4.0, которые можно скачать <a href="http://code.msdn.microsoft.com/csharpfuture/Release/ProjectReleases.aspx?ReleaseId=1686">отсюда</a> (там же есть документ New Features in C# 4.0, которая послужила основой для этого топика). Документацию по .Net Framework 4.0 beta 1 можно посмотреть <a href="http://msdn.microsoft.com/en-us/library/w0x726c2(VS.100).aspx">в MSDN</a>. Дальше будут следовать мой небольшой опыт знакомства с новой версией .NET. </p>

<h1>1. Dynamic Language Runtime</h1>

 <p>Изначально стоит взглянуть на следующую схему, иллюстрирующую архитектуру DLR:&nbsp;</p> 

<p><a href="/library/images/01/0000018.png"><img width="586" height="276" border="0" src="/library/images/01/0000018.png" alt="" /></a></p> 

<p>Именно! Теперь в .net можно еще и скриптовые языки использовать, такие как <em>IronRuby </em>и <em>IronPython</em>. Не думаю, что я буду этим пользоваться, но любителям экзотики предоставляю ссылки:</p>

<ul><li><a href="http://www.codeplex.com/IronPython">IronPython</a>.&nbsp;-&nbsp;open-source проект на <em>CodePlex</em>.</li><li><a href="http://rubyforge.org/projects/ironruby">IronRuby</a>. - open-source проект на&nbsp;<em>RubyForge</em>.</li></ul>

<p>Более того, предоставляется исходники <a href="http://dlr.codeplex.com/">DLR</a>, при помощи которых вы, наверняка, сможете создать свой динамический язык для .NET, если вам это необходимо</p>  

<p>Итак DLR включает в себя <em>Expression Trees</em>, которые просто являются представлением вызовов методов или бинарных операций в виде дерева,&nbsp;их функциональность можно посмотреть на следующем примере:</p>  

<div id="codeSnippetWrapper" style="background-color: #f4f4f4;color: black;font-family: 'Courier New', Courier, Monospace;	font-size: 9pt; line-height: 12pt; border: solid 1px silver; cursor: text; margin: 20px 0px 10px 0px; overflow: auto; padding: 4px; width: 97.5%; direction: ltr; text-align: left;"><div id="codeSnippet" >
<pre style="background-color: white;border-style: none; overflow: visible; padding: 0px; width: 100%; margin: 0em;">Expression&lt;Func&lt;<span style="color: #0000ff;">int</span>, <span style="color: #0000ff;">bool</span>&gt;&gt; exprTree = num =&gt; num &lt; 5;</pre><!--CRLF--><pre style="border-style: none; overflow: visible; padding: 0px; width: 100%; margin: 0em;"><span style="color: #008000;">// Decompose the expression tree.</span></pre><!--CRLF--><pre style="background-color: white;border-style: none; overflow: visible; padding: 0px; width: 100%; margin: 0em;">ParameterExpression param = (ParameterExpression)exprTree.Parameters[0];</pre><!--CRLF--><pre style="border-style: none; overflow: visible; padding: 0px; width: 100%; margin: 0em;">BinaryExpression operation = (BinaryExpression)exprTree.Body;</pre><!--CRLF--><pre style="background-color: white;border-style: none; overflow: visible; padding: 0px; width: 100%; margin: 0em;">ParameterExpression left = (ParameterExpression)operation.Left;</pre><!--CRLF--><pre style="border-style: none; overflow: visible; padding: 0px; width: 100%; margin: 0em;">ConstantExpression right = (ConstantExpression)operation.Right;</pre><!--CRLF--><pre style="background-color: white;border-style: none; overflow: visible; padding: 0px; width: 100%; margin: 0em;">Console.WriteLine(<span style="color: #006080;">"Decomposed expression: {0} =&gt; {1} {2} {3}"</span>,</pre><!--CRLF--><pre style="border-style: none; overflow: visible; padding: 0px; width: 100%; margin: 0em;">               param.Name, left.Name, operation.NodeType, right.Value);</pre><!--CRLF--></div></div>

<p>
В этом примере мы сначала описываем лямбда выражение&nbsp;<em>x=&gt;x&lt;5</em>, а&nbsp;затем при помощи объектов от Expression Trees разбираем данное выражение.</p>  

<p><em>Call Site caching </em>в DLR - это, насколько я понимаю, и есть динамическое представление вызовов методов динамических объектов или операций над динамическим объектами. DLR кеширует характеристики объектов (о типах объектах), а так же об операции, и если данная операция уже была выполнена ранее, тогда всю необходимую информацию DLR получит уже из кеша (вот как то так).</p>  

<p>И последнее в DLR это набор классов, интерфейсов: <em>IDynamicMetaObjectProvider, DynamicMetaObject, DynamicObject и ExpandoObject.</em> Давайте опять посмотрим на примере, как нам это может пригодиться, и зачем нам вообще нужен этот DLR:</p>

<div id="codeSnippetWrapper" style="background-color: #f4f4f4;color: black;font-family: 'Courier New', Courier, Monospace;	font-size: 9pt; line-height: 12pt; border: solid 1px silver; cursor: text; margin: 20px 0px 10px 0px; overflow: auto; padding: 4px; width: 97.5%; direction: ltr; text-align: left;"><div id="codeSnippet" >
<pre style="background-color: white;border-style: none; overflow: visible; padding: 0px; width: 100%; margin: 0em;"><span style="color: #0000ff;">class</span> Test1</pre><!--CRLF--><pre style="border-style: none; overflow: visible; padding: 0px; width: 100%; margin: 0em;">{</pre><!--CRLF--><pre style="background-color: white;border-style: none; overflow: visible; padding: 0px; width: 100%; margin: 0em;">}</pre><!--CRLF--><pre style="border-style: none; overflow: visible; padding: 0px; width: 100%; margin: 0em;">&nbsp;</pre><!--CRLF--><pre style="background-color: white;border-style: none; overflow: visible; padding: 0px; width: 100%; margin: 0em;"><span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> Main(<span style="color: #0000ff;">string</span>[] args)</pre><!--CRLF--><pre style="border-style: none; overflow: visible; padding: 0px; width: 100%; margin: 0em;">{</pre><!--CRLF--><pre style="background-color: white;border-style: none; overflow: visible; padding: 0px; width: 100%; margin: 0em;">  dynamic t = <span style="color: #0000ff;">new</span> Test1();</pre><!--CRLF--><pre style="border-style: none; overflow: visible; padding: 0px; width: 100%; margin: 0em;">  <span style="color: #0000ff;">string</span> str = t.Hello(); <span style="color: #008000;">// Error 1 </span></pre><!--CRLF--><pre style="background-color: white;border-style: none; overflow: visible; padding: 0px; width: 100%; margin: 0em;">&nbsp;</pre><!--CRLF--><pre style="border-style: none; overflow: visible; padding: 0px; width: 100%; margin: 0em;">  dynamic d = 7.0;</pre><!--CRLF--><pre style="background-color: white;border-style: none; overflow: visible; padding: 0px; width: 100%; margin: 0em;">  <span style="color: #0000ff;">int</span> i = d; <span style="color: #008000;">// Error 2</span></pre><!--CRLF--><pre style="border-style: none; overflow: visible; padding: 0px; width: 100%; margin: 0em;">}</pre><!--CRLF--></div></div>

<p>На удивление данный код скомпилируется и запустится. Все дело в волшебном слове <strong><em>dynamic</em></strong>, оно нам позволяет вызывать любые по имени свойства или методы, а так же приводить объект к любому типу. Во время Runtime (выполнения кода) вылетят ошибки, Error 1:&nbsp;о том, что метод не найден, Error 2: о том, что double невозможно привести к int. Попробуем их исправить:&nbsp;&nbsp;для исправления первой ошибки&nbsp;наш класс Test1 отнаследуем от типа System.Dynamic.DynamicObject и перегрузим один из методов, для исправления второй просто явно укажем преобразование типов:</p>   

<div id="codeSnippetWrapper" style="background-color: #f4f4f4;color: black;font-family: 'Courier New', Courier, Monospace;	font-size: 9pt; line-height: 12pt; border: solid 1px silver; cursor: text; margin: 20px 0px 10px 0px; overflow: auto; padding: 4px; width: 97.5%; direction: ltr; text-align: left;"><div id="codeSnippet" >
<pre style="background-color: white;border-style: none; overflow: visible; padding: 0px; width: 100%; margin: 0em;"><span style="color: #0000ff;">class</span> Test1 : DynamicObject</pre><!--CRLF--><pre style="border-style: none; overflow: visible; padding: 0px; width: 100%; margin: 0em;">{</pre><!--CRLF--><pre style="background-color: white;border-style: none; overflow: visible; padding: 0px; width: 100%; margin: 0em;">  <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">override</span> <span style="color: #0000ff;">bool</span> TryInvokeMember(InvokeMemberBinder binder, <span style="color: #0000ff;">object</span>[] args, <span style="color: #0000ff;">out</span> <span style="color: #0000ff;">object</span> result)</pre><!--CRLF--><pre style="border-style: none; overflow: visible; padding: 0px; width: 100%; margin: 0em;">  {</pre><!--CRLF--><pre style="background-color: white;border-style: none; overflow: visible; padding: 0px; width: 100%; margin: 0em;">    <span style="color: #0000ff;">if</span> (binder.Name == <span style="color: #006080;">"Hello"</span>)</pre><!--CRLF--><pre style="border-style: none; overflow: visible; padding: 0px; width: 100%; margin: 0em;">    {</pre><!--CRLF--><pre style="background-color: white;border-style: none; overflow: visible; padding: 0px; width: 100%; margin: 0em;">      result = <span style="color: #006080;">"Test1 is Dynamic Object!"</span>;</pre><!--CRLF--><pre style="border-style: none; overflow: visible; padding: 0px; width: 100%; margin: 0em;">      <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">true</span>;</pre><!--CRLF--><pre style="background-color: white;border-style: none; overflow: visible; padding: 0px; width: 100%; margin: 0em;">    }</pre><!--CRLF--><pre style="border-style: none; overflow: visible; padding: 0px; width: 100%; margin: 0em;">    <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">base</span>.TryInvokeMember(binder, args, <span style="color: #0000ff;">out</span> result);</pre><!--CRLF--><pre style="background-color: white;border-style: none; overflow: visible; padding: 0px; width: 100%; margin: 0em;">  }</pre><!--CRLF--><pre style="border-style: none; overflow: visible; padding: 0px; width: 100%; margin: 0em;">}</pre><!--CRLF--><pre style="background-color: white;border-style: none; overflow: visible; padding: 0px; width: 100%; margin: 0em;">&nbsp;</pre><!--CRLF--><pre style="border-style: none; overflow: visible; padding: 0px; width: 100%; margin: 0em;"><span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> Main(<span style="color: #0000ff;">string</span>[] args)</pre><!--CRLF--><pre style="background-color: white;border-style: none; overflow: visible; padding: 0px; width: 100%; margin: 0em;">{</pre><!--CRLF--><pre style="border-style: none; overflow: visible; padding: 0px; width: 100%; margin: 0em;">  dynamic t = <span style="color: #0000ff;">new</span> Test1();</pre><!--CRLF--><pre style="background-color: white;border-style: none; overflow: visible; padding: 0px; width: 100%; margin: 0em;">  <span style="color: #0000ff;">string</span> str = t.Hello(); </pre><!--CRLF--><pre style="border-style: none; overflow: visible; padding: 0px; width: 100%; margin: 0em;">&nbsp;</pre><!--CRLF--><pre style="background-color: white;border-style: none; overflow: visible; padding: 0px; width: 100%; margin: 0em;">  dynamic d = 7.0;</pre><!--CRLF--><pre style="border-style: none; overflow: visible; padding: 0px; width: 100%; margin: 0em;">  <span style="color: #0000ff;">int</span> i = (<span style="color: #0000ff;">int</span>) d;</pre><!--CRLF--><pre style="background-color: white;border-style: none; overflow: visible; padding: 0px; width: 100%; margin: 0em;">}</pre><!--CRLF--></div></div>

<p>
Теперь наш код будет работать. Переменная <em>str </em>получить значение <em>&quot;Test1 is dynamic object!&quot;</em>, а <em>i </em>значение <em>7</em>.</p>   <p></p>   <p>Конечно, необязательно наследоваться от класса&nbsp;<em>DynamicObject</em>, можно отнаследоваться и от интерфейса <em>IDynamicMetaObjectProvider</em>, но тогда нужно будет самому реализовывать&nbsp;метод&nbsp;&nbsp;<em>DynamicMetaObject GetMetaObject(Expression parameter)</em>, и более того реализовывать свой тип, унаследованный от <em>DynamicMetaObject</em>, ну в любом случае варианты есть - так что можно взять на вооружение. </p>   


<h1>2. Именованные и необязательные параметры в методах</h1>

<p>Это достаточно простая функциональность и уже много где оговорена, она хорошо описана вот например <a href="http://habrahabr.ru/blogs/net/43814/">тут</a> (на русском языке одним из автором хабрахабра). Если парой слов, то это возможность устанавливать дефолтные значения у параметров методов, а так же возможность установки значения параметра по имени при вызове метода. В общем пример будет лучшим объяснением:</p>      

<div id="codeSnippetWrapper" style="background-color: #f4f4f4;color: black;font-family: 'Courier New', Courier, Monospace;	font-size: 9pt; line-height: 12pt; border: solid 1px silver; cursor: text; margin: 20px 0px 10px 0px; overflow: auto; padding: 4px; width: 97.5%; direction: ltr; text-align: left;"><div id="codeSnippet" >
<pre style="background-color: white;border-style: none; overflow: visible; padding: 0px; width: 100%; margin: 0em;"><span style="color: #0000ff;">class</span> Test1 </pre><!--CRLF--><pre style="border-style: none; overflow: visible; padding: 0px; width: 100%; margin: 0em;">{</pre><!--CRLF--><pre style="background-color: white;border-style: none; overflow: visible; padding: 0px; width: 100%; margin: 0em;">  <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span> Method(<span style="color: #0000ff;">int</span> a = 0, <span style="color: #0000ff;">string</span> b = <span style="color: #006080;">"Hello"</span>, <span style="color: #0000ff;">bool</span> c = <span style="color: #0000ff;">true</span>)</pre><!--CRLF--><pre style="border-style: none; overflow: visible; padding: 0px; width: 100%; margin: 0em;">  {</pre><!--CRLF--><pre style="background-color: white;border-style: none; overflow: visible; padding: 0px; width: 100%; margin: 0em;">    Console.WriteLine(<span style="color: #006080;">"{0}, {1}, {2}"</span>, a, b, c);</pre><!--CRLF--><pre style="border-style: none; overflow: visible; padding: 0px; width: 100%; margin: 0em;">  }</pre><!--CRLF--><pre style="background-color: white;border-style: none; overflow: visible; padding: 0px; width: 100%; margin: 0em;">}</pre><!--CRLF--><pre style="border-style: none; overflow: visible; padding: 0px; width: 100%; margin: 0em;">&nbsp;</pre><!--CRLF--><pre style="background-color: white;border-style: none; overflow: visible; padding: 0px; width: 100%; margin: 0em;"><span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> Main(<span style="color: #0000ff;">string</span>[] args)</pre><!--CRLF--><pre style="border-style: none; overflow: visible; padding: 0px; width: 100%; margin: 0em;">{</pre><!--CRLF--><pre style="background-color: white;border-style: none; overflow: visible; padding: 0px; width: 100%; margin: 0em;">  Test1 o = <span style="color: #0000ff;">new</span> Test1();</pre><!--CRLF--><pre style="border-style: none; overflow: visible; padding: 0px; width: 100%; margin: 0em;">  <span style="color: #008000;">// Вызовем по как обычно</span></pre><!--CRLF--><pre style="background-color: white;border-style: none; overflow: visible; padding: 0px; width: 100%; margin: 0em;">  o.Method(1, <span style="color: #006080;">"Hello"</span>, <span style="color: #0000ff;">true</span>);</pre><!--CRLF--><pre style="border-style: none; overflow: visible; padding: 0px; width: 100%; margin: 0em;">  <span style="color: #008000;">// А можно поменять порядок параметров</span></pre><!--CRLF--><pre style="background-color: white;border-style: none; overflow: visible; padding: 0px; width: 100%; margin: 0em;">  o.Method(b: <span style="color: #006080;">"hello"</span>, c: <span style="color: #0000ff;">true</span>, a: 1);</pre><!--CRLF--><pre style="border-style: none; overflow: visible; padding: 0px; width: 100%; margin: 0em;">  <span style="color: #008000;">// Можно вообще ничего не вызывать</span></pre><!--CRLF--><pre style="background-color: white;border-style: none; overflow: visible; padding: 0px; width: 100%; margin: 0em;">  <span style="color: #008000;">// (установлены значения по умолчанию у всех параметров)</span></pre><!--CRLF--><pre style="border-style: none; overflow: visible; padding: 0px; width: 100%; margin: 0em;">  o.Method();</pre><!--CRLF--><pre style="background-color: white;border-style: none; overflow: visible; padding: 0px; width: 100%; margin: 0em;">  <span style="color: #008000;">// Можно определить только необходимые параметры</span></pre><!--CRLF--><pre style="border-style: none; overflow: visible; padding: 0px; width: 100%; margin: 0em;">  o.Method(1, <span style="color: #006080;">"Hello"</span>);</pre><!--CRLF--><pre style="background-color: white;border-style: none; overflow: visible; padding: 0px; width: 100%; margin: 0em;">  <span style="color: #008000;">// И не обязательно по порядку</span></pre><!--CRLF--><pre style="border-style: none; overflow: visible; padding: 0px; width: 100%; margin: 0em;">  o.Method(c: <span style="color: #0000ff;">false</span>);</pre><!--CRLF--><pre style="background-color: white;border-style: none; overflow: visible; padding: 0px; width: 100%; margin: 0em;">}</pre><!--CRLF--></div></div>

<p>
Теперь из- за переименование параметра метода, код может и не скомпилироваться, если кто-то использовал установку значения по имени, так что нужно быть аккуратнее. Я рад дефолтным значениям, и постараюсь не использовать функциональность именованных параметров. </p>   

<p>В дополнение хочу сказать, что если все таки будет у класса <em>Test1 </em>метод <em>void Method(int a)</em>, тогда при вызове <em>o.Method(1)</em> вызовится именно он, а не метод из примера с дефолтными значениями.</p>  

<h1>3. Возможности для COM Interop</h1>

<p>DLR так же&nbsp;дал новые&nbsp;возможности для COM&nbsp;Interop, теперь &nbsp;можно COM объекты определять как динамические (точнее они уже являются в большинстве своем динамического типа) и не приводить постоянно получаемые объекты к определенным типам для вызова методов или свойств. </p>

<div id="codeSnippetWrapper" style="background-color: #f4f4f4;color: black;font-family: 'Courier New', Courier, Monospace;	font-size: 9pt; line-height: 12pt; border: solid 1px silver; cursor: text; margin: 20px 0px 10px 0px; overflow: auto; padding: 4px; width: 97.5%; direction: ltr; text-align: left;"><div id="codeSnippet" >
<pre style="background-color: white;border-style: none; overflow: visible; padding: 0px; width: 100%; margin: 0em;">excel.Cells[1, 1].Value = <span style="color: #006080;">"Hello"</span>;</pre><!--CRLF--><pre style="border-style: none; overflow: visible; padding: 0px; width: 100%; margin: 0em;"><span style="color: #008000;">// вместо </span></pre><!--CRLF--><pre style="background-color: white;border-style: none; overflow: visible; padding: 0px; width: 100%; margin: 0em;">((Excel.Range)excel.Cells[1, 1]).Value2 = <span style="color: #006080;">"Hello"</span>;</pre><!--CRLF--></div></div>

<p>Данный пример взят из документа New Futures in C# 4.0 С одной стороны приятно, что теперь не нужно мучаться и находить к какому же типу нужно привести объект, чтобы вызвать его свойство или метод, но с другой стороны теряется IntelliSense.</p>   

<h1>4. Новое в generic</h1> 

<p>Теперь обогатился и generic новой функциональностью. Можно теперь у интерфейсов и у делегатов перед определением generic типов писать <em><strong>out </strong></em>и <em><strong>in</strong></em>, зачем это чуть дальше, а сначала рассмотрим пример.</p>   

<p>При работе с generic часто хочется сделать что то типа такого:</p>

<div id="codeSnippetWrapper" style="background-color: #f4f4f4;color: black;font-family: 'Courier New', Courier, Monospace;	font-size: 9pt; line-height: 12pt; border: solid 1px silver; cursor: text; margin: 20px 0px 10px 0px; overflow: auto; padding: 4px; width: 97.5%; direction: ltr; text-align: left;"><div id="codeSnippet" >
<pre style="background-color: white;border-style: none; overflow: visible; padding: 0px; width: 100%; margin: 0em;">IList&lt;<span style="color: #0000ff;">string</span>&gt; strings = <span style="color: #0000ff;">new</span> List&lt;<span style="color: #0000ff;">string</span>&gt;();</pre><!--CRLF--><pre style="border-style: none; overflow: visible; padding: 0px; width: 100%; margin: 0em;">IList&lt;<span style="color: #0000ff;">object</span>&gt; objects = strings;</pre><!--CRLF--></div></div>

<p>Но нельзя. Потому, что следом можно написать:</p>

<div id="codeSnippetWrapper" style="background-color: #f4f4f4;color: black;font-family: 'Courier New', Courier, Monospace;	font-size: 9pt; line-height: 12pt; border: solid 1px silver; cursor: text; margin: 20px 0px 10px 0px; overflow: auto; padding: 4px; width: 97.5%; direction: ltr; text-align: left;"><div id="codeSnippet" >
<pre style="background-color: white;border-style: none; overflow: visible; padding: 0px; width: 100%; margin: 0em;">objects[0] = 5;</pre><!--CRLF--><pre style="border-style: none; overflow: visible; padding: 0px; width: 100%; margin: 0em;"><span style="color: #0000ff;">string</span> s = strings[0];</pre><!--CRLF--></div></div>

<p>То есть, изначально у нас был список строк, потом обозначили его как список объектов, и хотим уже работать с ним, как с объектами, устанавливая любой другой объект в него, хотя список до сих пор является списком строк. </p>   

<p>Но, если вдуматься, то можно представить, что если бы список был только для чтения, то мы бы уже не смогли ничего нарушить, и там бы логика была ясна, потому&nbsp;следующий код на C# 4.0&nbsp;будет работать:</p>

<div id="codeSnippetWrapper" style="background-color: #f4f4f4;color: black;font-family: 'Courier New', Courier, Monospace;	font-size: 9pt; line-height: 12pt; border: solid 1px silver; cursor: text; margin: 20px 0px 10px 0px; overflow: auto; padding: 4px; width: 97.5%; direction: ltr; text-align: left;"><div id="codeSnippet" >
<pre style="background-color: white;border-style: none; overflow: visible; padding: 0px; width: 100%; margin: 0em;">IEnumerable&lt;<span style="color: #0000ff;">object</span>&gt; objects = strings;</pre><!--CRLF--></div></div>

<p>Огромную полезность данная функциональность принесет в работе с linq, там часто возникают проблемы, что возвращаем объекты одного типа, а нужно получить список другого типа (базового).</p>  

<p>Итак, как же такое стало возможным. Сначала рассмотрим слово <em><strong>out</strong></em>. Теперь интерфейс <em>IEnumerable&lt;T&gt;</em> объявлен как <em>IEnumerable&lt;out T&gt;</em>, где <em><strong>out </strong></em>обозначает, что тип <em>T </em>может быть использован только для возвращения значений, в другом случае компилятор будет ругаться, ну и более того это дает нам, что интерфейс <em>IEnumerable&lt;A&gt;</em> так же есть и <em>IEnumerable&lt;B&gt;</em>, если у <em>A </em>есть возможность приведения типа к <em>B</em>, если на простом примере, то <em>IEnumerable&lt;string&gt;</em>, есть теперь и <em>IEnumerable&lt;object&gt;</em>. Вот пример:</p>   

<div id="codeSnippetWrapper" style="background-color: #f4f4f4;color: black;font-family: 'Courier New', Courier, Monospace;	font-size: 9pt; line-height: 12pt; border: solid 1px silver; cursor: text; margin: 20px 0px 10px 0px; overflow: auto; padding: 4px; width: 97.5%; direction: ltr; text-align: left;"><div id="codeSnippet" >
<pre style="background-color: white;border-style: none; overflow: visible; padding: 0px; width: 100%; margin: 0em;"><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">interface</span> IEnumerable&lt;<span style="color: #0000ff;">out</span> T&gt; : IEnumerable</pre><!--CRLF--><pre style="border-style: none; overflow: visible; padding: 0px; width: 100%; margin: 0em;">{</pre><!--CRLF--><pre style="background-color: white;border-style: none; overflow: visible; padding: 0px; width: 100%; margin: 0em;">  IEnumerator&lt;T&gt; GetEnumerator();</pre><!--CRLF--><pre style="border-style: none; overflow: visible; padding: 0px; width: 100%; margin: 0em;">}</pre><!--CRLF--><pre style="background-color: white;border-style: none; overflow: visible; padding: 0px; width: 100%; margin: 0em;"><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">interface</span> IEnumerator&lt;<span style="color: #0000ff;">out</span> T&gt; : IEnumerator</pre><!--CRLF--><pre style="border-style: none; overflow: visible; padding: 0px; width: 100%; margin: 0em;">{</pre><!--CRLF--><pre style="background-color: white;border-style: none; overflow: visible; padding: 0px; width: 100%; margin: 0em;">  <span style="color: #0000ff;">bool</span> MoveNext();</pre><!--CRLF--><pre style="border-style: none; overflow: visible; padding: 0px; width: 100%; margin: 0em;">  T Current { get; }</pre><!--CRLF--><pre style="background-color: white;border-style: none; overflow: visible; padding: 0px; width: 100%; margin: 0em;">}</pre><!--CRLF--></div></div>

<p>Есть еще слово <em><strong>in</strong></em>. Его так же можно использовать в описании generic делегатов и интерфейсов. Несет оно такую же смысл как и слово <em><strong>out</strong></em>, только в данному случае описанный тип можно использовать только в передаче параметров, вот пример:</p>   

<div id="codeSnippetWrapper" style="background-color: #f4f4f4;color: black;font-family: 'Courier New', Courier, Monospace;	font-size: 9pt; line-height: 12pt; border: solid 1px silver; cursor: text; margin: 20px 0px 10px 0px; overflow: auto; padding: 4px; width: 97.5%; direction: ltr; text-align: left;"><div id="codeSnippet" >
<pre style="background-color: white;border-style: none; overflow: visible; padding: 0px; width: 100%; margin: 0em;"><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">interface</span> IComparer&lt;<span style="color: #0000ff;">in</span> T&gt;</pre><!--CRLF--><pre style="border-style: none; overflow: visible; padding: 0px; width: 100%; margin: 0em;">{</pre><!--CRLF--><pre style="background-color: white;border-style: none; overflow: visible; padding: 0px; width: 100%; margin: 0em;">  <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">int</span> Compare(T left, T right);</pre><!--CRLF--><pre style="border-style: none; overflow: visible; padding: 0px; width: 100%; margin: 0em;">}</pre><!--CRLF--></div></div>

<p>То есть в данном случае, если<em> IComparer&lt;object&gt; </em>может считаться и <em>IComparer&lt;string&gt;</em>, потому как если уж он может сравнивать объекты типа <em>object</em>, то и <em>string </em>тоже может.</p>   

<p>Так же, как я уже сказал, слова <em><strong>out </strong></em>и <em><strong>in </strong></em>можно применять и к интерфейсам, так, например:</p> 

<div id="codeSnippetWrapper" style="background-color: #f4f4f4;color: black;font-family: 'Courier New', Courier, Monospace;	font-size: 9pt; line-height: 12pt; border: solid 1px silver; cursor: text; margin: 20px 0px 10px 0px; overflow: auto; padding: 4px; width: 97.5%; direction: ltr; text-align: left;"><div id="codeSnippet" >
<pre style="background-color: white;border-style: none; overflow: visible; padding: 0px; width: 100%; margin: 0em;"><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">delegate</span> TResult Func&lt;<span style="color: #0000ff;">in</span> TArg, <span style="color: #0000ff;">out</span> TResult&gt;(TArg arg);</pre><!--CRLF--></div></div>

<h1>Заключение</h1>

<p>Так же в .NET 4.0 появилось много новвовведений, таких как&nbsp; <em>Lazy Initialiation</em> - память под объект выделяется тогда, когда это действительно становится нужно. Появились новые типы, как например, <a href="http://msdn.microsoft.com/en-us/library/system.numerics.biginteger(VS.100).aspx"><em>BigInteger </em></a>- теперь не нужно для лабораторных работ студентам писать свои классы для работы с большими числами ;), <a href="http://msdn.microsoft.com/en-us/library/dd412070(VS.100).aspx"><em>SortedSet&lt;T&gt;</em></a> - класс представляет собой самостоятельное балансированное дерево, которое сохраняет данные в отсортированном порядке после вставки, удаления и поиска. В общем, есть еще что изучать.</p>
